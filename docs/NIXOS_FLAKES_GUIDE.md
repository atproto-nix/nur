# NixOS Flakes & Repository Architecture Guide

**Complete Guide to Flakes, Repository Structure, and NixOS Configuration Management**

This guide covers best practices for structuring NixOS repositories, managing Home Manager, handling secrets, and setting up CI/CD pipelines.

---

## 1. Flake Output Schema: Standard Repository Entrypoints

The `flake.nix` file is the foundation of a standardized Nix/NixOS configuration repository. It defines an `outputs` attribute which is a function accepting:
- `self` - Reference to the flake's own outputs
- `inputs` - External dependencies (nixpkgs, home-manager, etc.)

The `outputs` attribute defines a standardized "API" that tools consume, transforming a collection of files into a structured project.

### 1.1 Core Configuration Outputs

These are the primary entrypoints consumed by system and user-level management tools.

#### nixosConfigurations.<hostname>

Maps unique hostnames to NixOS system configurations:

```nix
outputs = { self, nixpkgs, ... }: {
  nixosConfigurations.my-server = nixpkgs.lib.nixosSystem {
    system = "x86_64-linux";
    modules = [
      ./hosts/my-server/default.nix
      ./modules/nixos/common.nix
    ];
  };
};
```

**Deploy with**: `nixos-rebuild switch --flake .#my-server`

#### homeConfigurations.<username>

Maps usernames to Home Manager configurations (usually formatted as `username@hostname`):

```nix
outputs = { self, nixpkgs, home-manager, ... }: {
  homeConfigurations."user@hostname" = home-manager.lib.homeManagerConfiguration {
    pkgs = nixpkgs.legacyPackages.x86_64-linux;
    modules = [ ./home-manager/home.nix ];
  };
};
```

**Deploy with**: `home-manager switch --flake .#user@hostname`

#### darwinConfigurations.<hostname>

The macOS equivalent of `nixosConfigurations` for nix-darwin:

```nix
outputs = { self, nixpkgs, nix-darwin, ... }: {
  darwinConfigurations.my-mac = nix-darwin.lib.darwinSystem {
    modules = [ ./hosts/my-mac/default.nix ];
  };
};
```

### 1.2 Component Outputs (Modules, Packages, Overlays)

These expose reusable components for consumption by other flakes or internal configurations.

#### nixosModules

An attribute set of NixOS modules defining system options and configuration:

```nix
outputs = { self, ... }: {
  nixosModules.default = import ./modules/nixos;
  nixosModules.common = import ./modules/nixos/common.nix;
  nixosModules.feature = import ./modules/nixos/feature.nix;
};
```

#### packages.<system>

Buildable package derivations for a specific system:

```nix
outputs = { self, nixpkgs, ... }: {
  packages.x86_64-linux.my-app = nixpkgs.callPackage ./pkgs/my-app {};
  packages.aarch64-linux.my-app = nixpkgs.callPackage ./pkgs/my-app {};
};
```

**Build with**: `nix build .#my-app`

#### legacyPackages.<system>

Functionally identical to `packages` but **not evaluated** by `nix flake show`. This is a performance optimization for large package sets:

```nix
outputs = { self, nixpkgs, ... }: {
  legacyPackages.x86_64-linux = nixpkgs;
};
```

Use this for large package collections to avoid latency in tooling.

#### overlays

Functions that modify the nixpkgs package set:

```nix
outputs = { self, ... }: {
  overlays.default = final: prev: {
    my-patched-app = prev.my-app.override { /* ... */ };
  };
};
```

**Note**: Defining an overlay does NOT apply it. You must explicitly import it in your NixOS configuration.

#### devShells.<system>

Reproducible development environments (replacement for `nix-shell`):

```nix
outputs = { self, nixpkgs, ... }: {
  devShells.x86_64-linux.default = nixpkgs.mkShell {
    buildInputs = [ nixpkgs.nix nixpkgs.git ];
  };
};
```

**Activate with**: `nix develop` or `direnv use flake`

---

## 2. Repository Structure and Modularization Patterns

### 2.1 Single-Host Structure (Minimal)

For simple configurations, a flake.nix can directly import configuration.nix:

```
/etc/nixos/
├── flake.nix
├── configuration.nix
└── home.nix
```

**Limitation**: Does not scale beyond single host; leads to monolithic, unmaintainable files.

### 2.2 Multi-Host "Hosts and Modules" Architecture (Recommended)

This is the most robust pattern for managing multiple systems. It separates shared logic (modules) from host-specific configuration.

```
flake.nix
hosts/
├── my-laptop/
│   ├── default.nix          (Primary configuration for this host)
│   └── hardware-configuration.nix (Generated by nixos-generate-config)
├── my-server/
│   ├── default.nix
│   └── hardware-configuration.nix
modules/
├── nixos/
│   ├── common.nix           (Shared by all hosts)
│   ├── desktop.nix          (Desktop-specific features)
│   ├── services/
│   │   ├── webserver.nix
│   │   └── database.nix
│   └── hardware/
│       ├── nvidia.nix
│       └── audio.nix
├── home-manager/
│   ├── common.nix
│   ├── shell.nix
│   └── dev.nix
lib/
└── default.nix              (Helper functions)
```

### Implementation in flake.nix

```nix
outputs = { self, nixpkgs, ... }: {
  nixosConfigurations = {
    my-laptop = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        ./modules/nixos/common.nix
        ./modules/nixos/desktop.nix
        ./hosts/my-laptop/default.nix
      ];
    };
    my-server = nixpkgs.lib.nixosSystem {
      system = "x86_64-linux";
      modules = [
        ./modules/nixos/common.nix
        ./modules/nixos/services/webserver.nix
        ./hosts/my-server/default.nix
      ];
    };
  };
};
```

**Advantages**:
- ✅ Clear separation of concerns
- ✅ Shared configuration across hosts
- ✅ Explicit dependency graph
- ✅ Easy to understand and maintain

### 2.3 Alternative: flake-parts Framework

`flake-parts` is a higher-level abstraction that automates configuration based on directory structure:

```
configurations/
├── nixos/
│   ├── my-laptop.nix
│   └── my-server.nix
modules/
├── nixos/
│   ├── common.nix
│   └── features/
│       ├── desktop.nix
│       └── webserver.nix
```

**flake.nix**:
```nix
outputs = inputs: inputs.flake-parts.lib.mkFlake { inherit inputs; } {
  flake = { ... };
  systems = ["x86_64-linux" "aarch64-linux"];
  perSystem = { pkgs, ... }: { ... };
};
```

**Advantages**:
- ✅ Convention over configuration
- ✅ Reduces boilerplate
- ✅ Auto-wires outputs based on directory structure

**Disadvantages**:
- ❌ Less explicit; can be confusing for new users
- ❌ "Black magic" auto-wiring

---

## 3. Home Manager Integration

There are two mutually exclusive methods for integrating Home Manager with NixOS.

### 3.1 Method 1: The NixOS Module (System-Wide Integration)

Home Manager runs as a NixOS module. User configuration is applied **atomically** with system configuration.

**Setup**:

```nix
inputs = {
  nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
  home-manager = {
    url = "github:nix-community/home-manager";
    inputs.nixpkgs.follows = "nixpkgs";  # CRITICAL: Prevents diamond dependency
  };
};

outputs = { self, nixpkgs, home-manager, ... }: {
  nixosConfigurations.my-laptop = nixpkgs.lib.nixosSystem {
    modules = [
      ./configuration.nix
      home-manager.nixosModules.home-manager
      {
        home-manager.useGlobalPkgs = true;
        home-manager.useUserPackages = true;
        home-manager.users.my-user = import ./home-manager/home.nix;
      }
    ];
  };
};
```

**Deploy with**: `sudo nixos-rebuild switch --flake .#my-laptop`

**Characteristics**:
- ✅ Atomic updates (system and user together)
- ✅ Guaranteed consistency
- ❌ Requires sudo for user configuration
- ❌ Not portable to non-NixOS systems

### 3.2 Method 2: Standalone homeConfigurations (User-Specific)

Home Manager is managed independently. User configuration can be updated without system changes.

**Setup**:

```nix
outputs = { self, nixpkgs, home-manager, ... }: {
  homeConfigurations."my-user" = home-manager.lib.homeManagerConfiguration {
    pkgs = nixpkgs.legacyPackages.x86_64-linux;
    modules = [ ./home-manager/home.nix ];
  };

  # Can also define nixosConfiguration separately
  nixosConfigurations.my-laptop = nixpkgs.lib.nixosSystem {
    modules = [ ./configuration.nix ];
  };
};
```

**Deploy with**: `home-manager switch --flake .#my-user`

**Characteristics**:
- ✅ User-level updates without sudo
- ✅ Faster iteration (no system rebuild)
- ✅ Portable to non-NixOS systems
- ❌ System and user updates are not atomic

### 3.3 Recommended: Unified Model

Define both `nixosConfigurations` (Method 1) and `homeConfigurations` (Method 2) from the same underlying module:

```nix
outputs = { self, nixpkgs, home-manager, ... }:
let
  common-home = { config, lib, pkgs, ... }: {
    # Shared home-manager configuration
  };
in {
  nixosConfigurations.my-laptop = nixpkgs.lib.nixosSystem {
    modules = [
      ./configuration.nix
      home-manager.nixosModules.home-manager
      { home-manager.users.my-user = common-home; }
    ];
  };

  homeConfigurations."my-user" = home-manager.lib.homeManagerConfiguration {
    pkgs = nixpkgs.legacyPackages.x86_64-linux;
    modules = [ common-home ];
  };
};
```

**Benefits**:
- ✅ Atomic deployment on NixOS
- ✅ Portable to non-NixOS systems
- ✅ Code reuse between methods

### 3.4 Critical: The `inputs.nixpkgs.follows` Line

⚠️ **CRITICAL REQUIREMENT**: Always include `inputs.nixpkgs.follows = "nixpkgs"` in your home-manager input declaration.

**Without this line**:
- Home Manager uses its own pinned nixpkgs version
- Causes "diamond dependency" conflict
- Results in two copies of all core libraries
- Causes severe build and runtime errors

---

## 4. Package Management: outputs.packages vs. outputs.overlays

### 4.1 outputs.packages

**Purpose**: Define new, self-contained derivations (buildable packages)

```nix
outputs = { self, nixpkgs, ... }: {
  packages.x86_64-linux = {
    my-app = nixpkgs.callPackage ./pkgs/my-app {};
    another-tool = nixpkgs.callPackage ./pkgs/another-tool {};
  };
};
```

**Characteristics**:
- Definitions are isolated
- Do not modify the nixpkgs package set
- Suitable for new applications or leaf packages
- **Build with**: `nix build .#my-app`

### 4.2 outputs.overlays

**Purpose**: Modify an existing nixpkgs instance (global changes)

```nix
outputs = { self, ... }: {
  overlays.default = final: prev: {
    openssl = prev.openssl.overrideAttrs (old: { ... });
    my-custom-gcc = prev.gcc.override { ... };
  };
};
```

**Characteristics**:
- Changes apply globally across entire nixpkgs
- Any package depending on modified attribute receives new version
- Suitable for system-wide patches
- **Apply in NixOS config**: `nixpkgs.overlays = [ self.overlays.default ];`

### 4.3 When to Use Each

| Need | Use |
|------|-----|
| Define new, standalone application | `packages.x86_64-linux.my-app` |
| Override a leaf package (no dependents) | `packages.x86_64-linux.patched-tool` |
| Patch deeply nested dependency (e.g., openssl) | `overlays.default` |
| Apply system-wide configuration change | `overlays.default` |

### 4.4 Anti-Patterns

❌ **Do NOT** use `import nixpkgs` inside `outputs.packages`. This negates performance, caching, and reproducibility benefits.

❌ **Do NOT** apply overlays by defining them in flake.nix. Defining an overlay merely makes it available for others to consume. To apply it to your own configuration, explicitly import it:

```nix
# ❌ WRONG - Overlay not applied
outputs = { self, nixpkgs, ... }: {
  overlays.default = final: prev: { ... };  # Just defined, not applied!
};

# ✅ CORRECT - Overlay applied in NixOS config
modules = [
  { nixpkgs.overlays = [ self.overlays.default ]; }
  ./configuration.nix
];
```

---

## 5. Secrets Management: sops-nix vs. agenix

Storing secrets in Git repositories is critical security challenge. **Never store plaintext secrets**, even in private repos.

### 5.1 Anti-Pattern: Plaintext Encryption

❌ **Never use** `git-crypt` or `builtins.toFile` with encrypted secrets. These decrypt at build time, leaking plaintext into `/nix/store` (world-readable).

**Correct approach**: Decrypt secrets **at activation time** on the target host only.

### 5.2 sops-nix (Comprehensive)

Built on Mozilla's sops. Supports multiple encryption backends:

**Setup**:

```nix
inputs.sops-nix.url = "github:Mic92/sops-nix";

outputs = { self, nixpkgs, sops-nix, ... }: {
  nixosConfigurations.my-server = nixpkgs.lib.nixosSystem {
    modules = [
      sops-nix.nixosModules.sops
      {
        sops.defaultSopsFile = ./secrets.yaml;
        sops.age.sshKeyPaths = [ "/etc/ssh/ssh_host_ed25519_key" ];

        sops.secrets."db-password" = {
          owner = "postgres";
          group = "postgres";
          mode = "0400";
        };
      }
    ];
  };
};
```

**Encryption Backends**:
- age (fastest, recommended)
- GPG
- AWS KMS, GCP KMS, Azure Key Vault (cloud-native)
- Yubikey

**Characteristics**:
- ✅ Multiple encryption backends
- ✅ Team-friendly (multiple users)
- ✅ Enterprise-ready
- ✅ Home Manager support
- ❌ More complex setup

### 5.3 agenix (Simple)

Lightweight alternative focusing exclusively on age encryption:

**Setup**:

```nix
inputs.agenix.url = "github:ryantm/agenix";

# Generate secret file
agenix -e secrets/db-password.age

outputs = { self, nixpkgs, agenix, ... }: {
  nixosConfigurations.my-server = nixpkgs.lib.nixosSystem {
    modules = [
      agenix.nixosModules.age
      {
        age.secrets.db-password.file = ./secrets/db-password.age;
        age.secrets.db-password.owner = "postgres";
      }
    ];
  };
};
```

**Characteristics**:
- ✅ Simple, lightweight
- ✅ Single encryption backend (age)
- ✅ Uses SSH keys (no additional setup)
- ❌ No Home Manager support (native)
- ❌ Less flexible for teams

### 5.4 Comparison

| Feature | sops-nix | agenix |
|---------|----------|--------|
| Encryption Backend | Multiple (age, GPG, KMS) | age only |
| Complexity | Complex | Simple |
| Home Manager Support | Official module | Manual setup |
| Use Case | Teams, Enterprise | Single-user, Simple |
| Secret Path | `/run/secrets/` | `/run/secrets/...` |

**Recommendation**: Use **sops-nix** for multi-user/team environments. Use **agenix** for simple, single-user setups.

---

## 6. Dependency Management and CI/CD

### 6.1 Dependency Pinning (flake.lock)

The `flake.lock` file ensures **bit-for-bit reproducibility** by capturing exact Git revisions and content hashes of all inputs:

```json
{
  "nodes": {
    "nixpkgs": {
      "locked": {
        "owner": "nixos",
        "repo": "nixpkgs",
        "rev": "abc123def456...",
        "narHash": "sha256-XXXX..."
      }
    }
  }
}
```

**Must be committed to Git** to ensure everyone uses the same versions.

### 6.2 Update Strategy

**Update all inputs**:
```bash
nix flake update
```

**Update specific input (preferred)**:
```bash
nix flake lock --update-input nixpkgs
```

⚠️ **Avoid**: `nixos-rebuild switch --update-input nixpkgs`

This creates a "dirty" state - system is ahead of committed configuration.

### 6.3 Automated System Upgrades

NixOS can auto-update itself:

```nix
system.autoUpgrade = {
  enable = true;
  flake = inputs.self.outPath;
  flags = [ "--update-input" "nixpkgs" "--no-write-lock-file" ];
  dates = "02:00";          # Run at 2 AM
  randomizedDelaySec = "45min";
};
```

⚠️ **Note**: `--no-write-lock-file` means running system is "ahead" of committed lock. Better approach: CI job that updates and commits new lock file.

### 6.4 CI/CD Integration (GitHub Actions)

**Minimal GitHub Actions workflow**:

```yaml
name: "Nix CI"
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - uses: cachix/install-nix-action@v31
      with:
        github_access_token: ${{ secrets.GITHUB_TOKEN }}

    - uses: cachix/cachix-action@v15
      with:
        name: my-cache-name
        authToken: '${{ secrets.CACHIX_AUTH_TOKEN }}'

    - run: nix flake check          # Check all configurations
    - run: nix build .#my-server    # Build specific host
    - run: nix build .#my-laptop    # Build another host
```

**Benefits**:
- Validates all configurations on every push
- Populates binary cache (Cachix) for fast deployments
- Catches build errors early

---

## 7. Data Sharing: NixOS ↔ Home Manager

Sharing values between system-level and user-level configuration:

```nix
outputs = { self, nixpkgs, home-manager, ... }: {
  nixosConfigurations.my-laptop = nixpkgs.lib.nixosSystem {
    modules = [
      ./configuration.nix
      home-manager.nixosModules.home-manager
      {
        home-manager.useGlobalPkgs = true;
        home-manager.useUserPackages = true;

        # Pass system config to Home Manager via extraSpecialArgs
        home-manager.extraSpecialArgs = {
          my-theme = "dark";
          my-hostname = config.networking.hostname;
        };

        home-manager.users.my-user = { config, lib, my-theme, ... }: {
          home.sessionVariables.THEME = my-theme;
        };
      }
    ];
  };
};
```

---

## 8. Ecosystem Integration: nix-direnv

Automatically load reproducible development environments:

```bash
# Create .envrc in repository root
echo "use flake" > .envrc
direnv allow
```

**flake.nix**:
```nix
outputs = { self, nixpkgs, ... }: {
  devShells.x86_64-linux.default = nixpkgs.mkShell {
    buildInputs = [
      nixpkgs.nix
      nixpkgs.git
      nixpkgs.sops
      nixpkgs.age
    ];
  };
};
```

**Benefits**:
- ✅ Consistent tool versions
- ✅ Automatic environment setup
- ✅ No manual `nix develop` needed

---

## 9. Best Practices Summary

### Repository Structure
- ✅ Use "Hosts and Modules" pattern for clarity
- ✅ Separate shared config (modules/) from host-specific (hosts/)
- ✅ Keep hardware-configuration.nix version-controlled
- ✅ Use lib/ for helper functions

### Home Manager Integration
- ✅ Use unified model (both Method 1 and 2) for flexibility
- ✅ Include `inputs.nixpkgs.follows = "nixpkgs"` (CRITICAL)
- ✅ Share configuration via extraSpecialArgs

### Secrets Management
- ✅ Never commit plaintext secrets
- ✅ Decrypt at activation time, not build time
- ✅ Use sops-nix for teams, agenix for simple setups
- ✅ Keep decryption keys secure (SSH keys, encrypted)

### Package Management
- ✅ Use `packages` for new applications
- ✅ Use `overlays` for system-wide patches only
- ✅ Always explicitly apply overlays in NixOS config

### Dependency Management
- ✅ Commit flake.lock to Git
- ✅ Update dependencies explicitly: `nix flake lock --update-input nixpkgs`
- ✅ Use CI/CD to validate configurations

---

## Related Documentation

- **[CLAUDE.md](./CLAUDE.md)** - Implementation patterns for specific services
- **[NUR Best Practices](./NUR_BEST_PRACTICES.md)** - ATProto NUR architecture
- **[Documentation Index](./INDEX.md)** - All documentation

---

**Last Updated**: November 11, 2025
**Source**: NixOS best practices compilation
**Status**: Production-ready reference
